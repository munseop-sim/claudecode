# í”„ë¡œì íŠ¸ ì„¤ê³„

> **í”„ë¡œì íŠ¸ ì„¤ê³„ë€?**
> ì†Œí”„íŠ¸ì›¨ì–´ë¥¼ ê°œë°œí•˜ê¸° ì „ì— ì‹œìŠ¤í…œì˜ êµ¬ì¡°, ê¸°ìˆ  ìŠ¤íƒ, ì•„í‚¤í…ì²˜ íŒ¨í„´ ë“±ì„ ê²°ì •í•˜ëŠ” ë‹¨ê³„ì…ë‹ˆë‹¤.
> ì¢‹ì€ ì„¤ê³„ëŠ” ìœ ì§€ë³´ìˆ˜ì„±, í™•ì¥ì„±, í…ŒìŠ¤íŠ¸ ìš©ì´ì„±ì„ ë†’ì—¬ì¤ë‹ˆë‹¤.

## ğŸ’¡ Claude í™œìš© íŒ: í”„ë¡œì íŠ¸ ì„¤ê³„

### 1. ìš”êµ¬ì‚¬í•­ ë¶„ì„ ë° ì•„í‚¤í…ì²˜ ì„ íƒ
```
í”„ë¡¬í”„íŠ¸ ì˜ˆì‹œ:
"ì „ììƒê±°ë˜ í”Œë«í¼ì„ ë§Œë“¤ë ¤ê³  í•´. ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì´ ìˆì–´:
- ì‚¬ìš©ì, ìƒí’ˆ, ì£¼ë¬¸, ê²°ì œ ë„ë©”ì¸
- ì›” 10ë§Œëª…ì˜ ì‚¬ìš©ì ì˜ˆìƒ
- ì™¸ë¶€ ê²°ì œ API, ì¬ê³  ê´€ë¦¬ ì‹œìŠ¤í…œ ì—°ë™ í•„ìš”
- í–¥í›„ ëª¨ë°”ì¼ ì•±ë„ ì§€ì› ì˜ˆì •

ë ˆì´ì–´ë“œ ì•„í‚¤í…ì²˜ì™€ í—¥ì‚¬ê³ ë‚  ì•„í‚¤í…ì²˜ ì¤‘ ì–´ë–¤ ê²ƒì´ ì í•©í• ê¹Œ?
ê°ê°ì˜ ì¥ë‹¨ì ê³¼ ì´ í”„ë¡œì íŠ¸ì— ë§ëŠ” ì¶”ì²œì„ í•´ì¤˜."
```

**Claudeê°€ ë„ì™€ì¤„ ìˆ˜ ìˆëŠ” ê²ƒ**:
- í”„ë¡œì íŠ¸ ê·œëª¨ì™€ ë³µì¡ë„ì— ë”°ë¥¸ ì•„í‚¤í…ì²˜ ì¶”ì²œ
- ê° ì•„í‚¤í…ì²˜ì˜ íŠ¸ë ˆì´ë“œì˜¤í”„ ì„¤ëª…
- íŒ€ ìƒí™©(ê²½í—˜, ì¼ì •)ì„ ê³ ë ¤í•œ í˜„ì‹¤ì ì¸ ì¡°ì–¸

### 2. íŒ¨í‚¤ì§€ êµ¬ì¡° ì„¤ê³„
```
í”„ë¡¬í”„íŠ¸ ì˜ˆì‹œ:
"Spring Boot + Kotlinìœ¼ë¡œ ë ˆì´ì–´ë“œ ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•˜ëŠ”
ì „ììƒê±°ë˜ í”„ë¡œì íŠ¸ì˜ íŒ¨í‚¤ì§€ êµ¬ì¡°ë¥¼ ì„¤ê³„í•´ì¤˜.
User, Product, Order ë„ë©”ì¸ì´ ìˆê³ ,
ê° ë„ë©”ì¸ë§ˆë‹¤ CRUD ê¸°ëŠ¥ê³¼ ëª‡ ê°€ì§€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ ìˆì–´."
```

**ê²°ê³¼ë¬¼**: ì™„ì „í•œ ë””ë ‰í† ë¦¬ êµ¬ì¡°ì™€ ê° íŒ¨í‚¤ì§€ì˜ ì—­í•  ì„¤ëª…

### 3. ë„ë©”ì¸ ëª¨ë¸ë§
```
í”„ë¡¬í”„íŠ¸ ì˜ˆì‹œ:
"ì „ììƒê±°ë˜ì—ì„œ Order(ì£¼ë¬¸) ë„ë©”ì¸ì„ ì„¤ê³„í•˜ë ¤ê³  í•´.
- ì£¼ë¬¸ì€ ì—¬ëŸ¬ ì£¼ë¬¸ í•­ëª©(OrderItem)ì„ ê°€ì§
- ì£¼ë¬¸ ìƒíƒœ: PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
- ê° ìƒíƒœ ì „í™˜ì— ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ì´ ìˆìŒ

Kotlin data classë¡œ Entityì™€ DTOë¥¼ ì„¤ê³„í•˜ê³ ,
ìƒíƒœ ì „í™˜ ë¡œì§ë„ ì¶”ê°€í•´ì¤˜."
```

**Claudeê°€ ìƒì„±í•´ì£¼ëŠ” ê²ƒ**:
- JPA Entity ì„¤ê³„ (ì—°ê´€ê´€ê³„ í¬í•¨)
- ìƒíƒœ íŒ¨í„´ ë˜ëŠ” Sealed Classë¥¼ í™œìš©í•œ ìƒíƒœ ê´€ë¦¬
- DTO ë° Mapper í•¨ìˆ˜

## ì•„í‚¤í…ì²˜ ì„¤ê³„

### 1. ë ˆì´ì–´ë“œ ì•„í‚¤í…ì²˜ (Layered Architecture)
**ì •ì˜**: ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì—¬ëŸ¬ ê³„ì¸µìœ¼ë¡œ ë¶„ë¦¬í•˜ì—¬ ê° ê³„ì¸µì´ ëª…í™•í•œ ì±…ì„ì„ ê°€ì§€ë„ë¡ í•˜ëŠ” ì•„í‚¤í…ì²˜ íŒ¨í„´

**ì£¼ìš” ê³„ì¸µ**:
- **Presentation Layer (Controller)**: HTTP ìš”ì²­/ì‘ë‹µ ì²˜ë¦¬, ì…ë ¥ ê²€ì¦
- **Business Layer (Service)**: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ìˆ˜í–‰, íŠ¸ëœì­ì…˜ ê´€ë¦¬
- **Persistence Layer (Repository)**: ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼, ë°ì´í„° ì˜ì†í™”
- **Domain Layer (Entity/Model)**: ë„ë©”ì¸ ê°ì²´ ì •ì˜

**ê³„ì¸µ ê°„ ì˜ì¡´ì„± ê·œì¹™**:
```
Controller â†’ Service â†’ Repository â†’ Entity
(ìƒìœ„ ê³„ì¸µì€ í•˜ìœ„ ê³„ì¸µì—ë§Œ ì˜ì¡´)
```

**íŒ¨í‚¤ì§€ êµ¬ì¡° ì˜ˆì‹œ**:
```
com.example.project
â”œâ”€â”€ controller/      # API ì—”ë“œí¬ì¸íŠ¸
â”œâ”€â”€ service/         # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”œâ”€â”€ repository/      # ë°ì´í„° ì ‘ê·¼
â”œâ”€â”€ domain/          # ë„ë©”ì¸ ì—”í‹°í‹°
â”œâ”€â”€ dto/             # ë°ì´í„° ì „ì†¡ ê°ì²´
â””â”€â”€ config/          # ì„¤ì • í´ë˜ìŠ¤
```

**ì½”ë“œ ì˜ˆì‹œ**:
```kotlin
// Presentation Layer
@RestController
@RequestMapping("/api/users")
class UserController(
    private val userService: UserService  // í•˜ìœ„ ê³„ì¸µ ì˜ì¡´
) {
    @PostMapping
    fun createUser(@RequestBody request: UserCreateRequest) =
        userService.createUser(request)
}

// Business Layer
@Service
class UserService(
    private val userRepository: UserRepository  // í•˜ìœ„ ê³„ì¸µ ì˜ì¡´
) {
    @Transactional
    fun createUser(request: UserCreateRequest): User {
        return userRepository.save(request.toEntity())
    }
}

// Persistence Layer
interface UserRepository : JpaRepository<User, Long>

// Domain Layer
@Entity
data class User(
    @Id @GeneratedValue
    val id: Long = 0,
    val email: String,
    val name: String
)
```

**ì¥ì **:
- âœ… ì´í•´í•˜ê¸° ì‰½ê³  ì§ê´€ì 
- âœ… ê³„ì¸µë³„ ì—­í• ì´ ëª…í™•
- âœ… ì‘ì€~ì¤‘ê°„ ê·œëª¨ í”„ë¡œì íŠ¸ì— ì í•©
- âœ… Spring Bootì™€ ìì—°ìŠ¤ëŸ½ê²Œ í†µí•©

**ë‹¨ì **:
- âŒ ë°ì´í„°ë² ì´ìŠ¤ ì¤‘ì‹¬ ì„¤ê³„ (DBê°€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì§€ë°°)
- âŒ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ ì¸í”„ë¼ì— ì˜ì¡´ (Repository ì¸í„°í˜ì´ìŠ¤ê°€ JPAì— ì˜ì¡´)
- âŒ í…ŒìŠ¤íŠ¸ ì‹œ ì „ì²´ ê³„ì¸µì„ ëª¨í‚¹í•´ì•¼ í•  ìˆ˜ ìˆìŒ
- âŒ ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ í‘œí˜„í•˜ê¸° ì–´ë ¤ì›€

---

### 2. í—¥ì‚¬ê³ ë‚  ì•„í‚¤í…ì²˜ (Hexagonal Architecture / Ports and Adapters)
**ì •ì˜**: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì¤‘ì‹¬ì— ë‘ê³ , ì™¸ë¶€ ì‹œìŠ¤í…œ(DB, API, UI ë“±)ì„ êµì²´ ê°€ëŠ¥í•œ ì–´ëŒ‘í„°ë¡œ ë¶„ë¦¬í•˜ëŠ” ì•„í‚¤í…ì²˜ íŒ¨í„´

**ë³„ì¹­**: í¬íŠ¸ ì•¤ ì–´ëŒ‘í„° ì•„í‚¤í…ì²˜ (Ports and Adapters), í´ë¦° ì•„í‚¤í…ì²˜ì˜ í•œ í˜•íƒœ

**í•µì‹¬ ê°œë…**:
- **Domain (í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)**: ì™¸ë¶€ ì˜ì¡´ì„± ì—†ëŠ” ìˆœìˆ˜í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
- **Port (ì¸í„°í˜ì´ìŠ¤)**: ë‚´ë¶€ì™€ ì™¸ë¶€ë¥¼ ì—°ê²°í•˜ëŠ” ê³„ì•½
  - **Inbound Port (Use Case)**: ì• í”Œë¦¬ì¼€ì´ì…˜ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” ìš”ì²­ (ì˜ˆ: ì‚¬ìš©ì ìƒì„±)
  - **Outbound Port**: ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë‚˜ê°€ëŠ” ìš”ì²­ (ì˜ˆ: DB ì €ì¥, ì™¸ë¶€ API í˜¸ì¶œ)
- **Adapter (êµ¬í˜„ì²´)**: Portì˜ ì‹¤ì œ êµ¬í˜„
  - **Inbound Adapter**: REST Controller, GraphQL Resolver ë“±
  - **Outbound Adapter**: JPA Repository, HTTP Client ë“±

**ì˜ì¡´ì„± ê·œì¹™**:
```
Adapter â†’ Port â†’ Domain
(ëª¨ë“  ì˜ì¡´ì„±ì€ ì•ˆìª½(Domain)ì„ í–¥í•¨)
```

**íŒ¨í‚¤ì§€ êµ¬ì¡° ì˜ˆì‹œ**:
```
com.example.project
â”œâ”€â”€ domain/                      # í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (ì˜ì¡´ì„± ì—†ìŒ)
â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â””â”€â”€ User.kt
â”‚   â””â”€â”€ service/
â”‚       â””â”€â”€ UserDomainService.kt
â”‚
â”œâ”€â”€ application/                 # ìœ ìŠ¤ì¼€ì´ìŠ¤ (Inbound Port)
â”‚   â”œâ”€â”€ port/
â”‚   â”‚   â”œâ”€â”€ in/
â”‚   â”‚   â”‚   â””â”€â”€ CreateUserUseCase.kt      # ì¸í„°í˜ì´ìŠ¤
â”‚   â”‚   â””â”€â”€ out/
â”‚   â”‚       â””â”€â”€ UserPersistencePort.kt    # ì¸í„°í˜ì´ìŠ¤
â”‚   â””â”€â”€ service/
â”‚       â””â”€â”€ UserService.kt                # UseCase êµ¬í˜„
â”‚
â””â”€â”€ adapter/                     # ì–´ëŒ‘í„° (Port êµ¬í˜„)
    â”œâ”€â”€ in/
    â”‚   â””â”€â”€ web/
    â”‚       â””â”€â”€ UserController.kt         # Inbound Adapter
    â””â”€â”€ out/
        â””â”€â”€ persistence/
            â”œâ”€â”€ UserJpaEntity.kt
            â”œâ”€â”€ UserRepository.kt
            â””â”€â”€ UserPersistenceAdapter.kt  # Outbound Adapter
```

**ì½”ë“œ ì˜ˆì‹œ**:
```kotlin
// ===== Domain Layer (ì™¸ë¶€ ì˜ì¡´ì„± ì—†ìŒ) =====
// ìˆœìˆ˜í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ê°ì²´
data class User(
    val id: Long?,
    val email: String,
    val name: String
) {
    fun validateEmail() {
        require(email.contains("@")) { "Invalid email format" }
    }
}

// ===== Application Layer (Ports) =====
// Inbound Port (Use Case ì¸í„°í˜ì´ìŠ¤)
interface CreateUserUseCase {
    fun createUser(command: CreateUserCommand): User
}

data class CreateUserCommand(
    val email: String,
    val name: String
)

// Outbound Port (ì €ì¥ì†Œ ì¸í„°í˜ì´ìŠ¤ - ê¸°ìˆ  ë…ë¦½ì )
interface UserPersistencePort {
    fun save(user: User): User
    fun findByEmail(email: String): User?
}

// Use Case êµ¬í˜„
@Service
class UserService(
    private val persistencePort: UserPersistencePort  // ì¸í„°í˜ì´ìŠ¤ì—ë§Œ ì˜ì¡´
) : CreateUserUseCase {

    override fun createUser(command: CreateUserCommand): User {
        // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
        val user = User(
            id = null,
            email = command.email,
            name = command.name
        )
        user.validateEmail()

        // ì €ì¥ (ì–´ë–¤ DBì¸ì§€ ëª¨ë¦„)
        return persistencePort.save(user)
    }
}

// ===== Adapter Layer (Inbound) =====
@RestController
@RequestMapping("/api/users")
class UserController(
    private val createUserUseCase: CreateUserUseCase  // Use Caseì—ë§Œ ì˜ì¡´
) {
    @PostMapping
    fun createUser(@RequestBody request: CreateUserRequest): UserResponse {
        val command = CreateUserCommand(
            email = request.email,
            name = request.name
        )
        val user = createUserUseCase.createUser(command)
        return user.toResponse()
    }
}

// ===== Adapter Layer (Outbound) =====
// JPA Entity (Infrastructure ê´€ì‹¬ì‚¬)
@Entity
@Table(name = "users")
data class UserJpaEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    val email: String,
    val name: String
)

// JPA Repository
interface UserJpaRepository : JpaRepository<UserJpaEntity, Long> {
    fun findByEmail(email: String): UserJpaEntity?
}

// Persistence Adapter (Port êµ¬í˜„)
@Component
class UserPersistenceAdapter(
    private val jpaRepository: UserJpaRepository
) : UserPersistencePort {

    override fun save(user: User): User {
        val entity = UserJpaEntity(
            id = user.id,
            email = user.email,
            name = user.name
        )
        val saved = jpaRepository.save(entity)
        return saved.toDomain()
    }

    override fun findByEmail(email: String): User? {
        return jpaRepository.findByEmail(email)?.toDomain()
    }
}

// Mapper
fun UserJpaEntity.toDomain() = User(
    id = this.id,
    email = this.email,
    name = this.name
)
```

**ì¥ì **:
- âœ… ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ ì¸í”„ë¼ì— ë…ë¦½ì  (DB, í”„ë ˆì„ì›Œí¬ ë³€ê²½ ìš©ì´)
- âœ… í…ŒìŠ¤íŠ¸í•˜ê¸° ì‰¬ì›€ (Portë§Œ ëª¨í‚¹í•˜ë©´ ë¨)
- âœ… ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ í‘œí˜„í•˜ê¸° ì¢‹ìŒ
- âœ… ë„ë©”ì¸ ì¤‘ì‹¬ ì„¤ê³„ (DDDì™€ ì˜ ì–´ìš¸ë¦¼)
- âœ… ì™¸ë¶€ ì‹œìŠ¤í…œì„ ì‰½ê²Œ êµì²´ ê°€ëŠ¥ (H2 â†’ MySQL, REST â†’ GraphQL)

**ë‹¨ì **:
- âŒ ì´ˆê¸° ì„¤ì •ì´ ë³µì¡í•¨ (ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œ ì¦ê°€)
- âŒ ëŸ¬ë‹ ì»¤ë¸Œê°€ ë†’ìŒ
- âŒ ì‘ì€ í”„ë¡œì íŠ¸ì—ëŠ” ê³¼ë„í•œ ì„¤ê³„
- âŒ ë„ë©”ì¸ê³¼ ì¸í”„ë¼ ê°ì²´ ê°„ ë§¤í•‘ ë¹„ìš©

---

### ì•„í‚¤í…ì²˜ ë¹„êµí‘œ

| íŠ¹ì§• | ë ˆì´ì–´ë“œ ì•„í‚¤í…ì²˜ | í—¥ì‚¬ê³ ë‚  ì•„í‚¤í…ì²˜ |
|------|------------------|------------------|
| **ì˜ì¡´ì„± ë°©í–¥** | ìƒìœ„ â†’ í•˜ìœ„ (ë‹¨ë°©í–¥) | ì™¸ë¶€ â†’ ë‚´ë¶€ (Domain ì¤‘ì‹¬) |
| **í•µì‹¬** | ê³„ì¸µ ë¶„ë¦¬ | ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë³´í˜¸ |
| **ë³µì¡ë„** | ë‚®ìŒ | ë†’ìŒ |
| **í…ŒìŠ¤íŠ¸ ìš©ì´ì„±** | ë³´í†µ | ë†’ìŒ |
| **ìœ ì—°ì„±** | ë‚®ìŒ | ë†’ìŒ |
| **ì í•©í•œ í”„ë¡œì íŠ¸** | ì‘ì€~ì¤‘ê°„ ê·œëª¨, CRUD ì¤‘ì‹¬ | ì¤‘ê°„~ëŒ€ê·œëª¨, ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ |
| **ëŸ¬ë‹ ì»¤ë¸Œ** | ë‚®ìŒ | ë†’ìŒ |
| **ì¸í”„ë¼ ë…ë¦½ì„±** | ë‚®ìŒ (DB ì˜ì¡´ì ) | ë†’ìŒ (ì¸í”„ë¼ êµì²´ ìš©ì´) |

**ì„ íƒ ê°€ì´ë“œ**:
- **ë ˆì´ì–´ë“œ ì•„í‚¤í…ì²˜ë¥¼ ì„ íƒí•˜ëŠ” ê²½ìš°**:
  - CRUD ì¤‘ì‹¬ì˜ ê°„ë‹¨í•œ ì• í”Œë¦¬ì¼€ì´ì…˜
  - ë¹ ë¥¸ ê°œë°œì´ í•„ìš”í•œ ê²½ìš°
  - íŒ€ì›ì˜ Spring ê²½í—˜ì´ í’ë¶€í•˜ì§€ë§Œ DDD ê²½í—˜ì´ ë¶€ì¡±í•œ ê²½ìš°

- **í—¥ì‚¬ê³ ë‚  ì•„í‚¤í…ì²˜ë¥¼ ì„ íƒí•˜ëŠ” ê²½ìš°**:
  - ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ê°€ì§„ ë„ë©”ì¸
  - ì™¸ë¶€ ì‹œìŠ¤í…œ í†µí•©ì´ ë§ì€ ê²½ìš°
  - ì¥ê¸°ì ì¸ ìœ ì§€ë³´ìˆ˜ì™€ í™•ì¥ì„±ì´ ì¤‘ìš”í•œ ê²½ìš°
  - ë†’ì€ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ê°€ í•„ìš”í•œ ê²½ìš°

### ë„ë©”ì¸ ëª¨ë¸ë§ (Domain Modeling)
**ì •ì˜**: ë¹„ì¦ˆë‹ˆìŠ¤ ë„ë©”ì¸ì˜ ê°œë…ì„ ì½”ë“œë¡œ í‘œí˜„í•˜ëŠ” ê³¼ì •

**Kotlin data class í™œìš©**:
```kotlin
// Entity: ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸”ê³¼ ë§¤í•‘ë˜ëŠ” ì˜ì†ì„± ê°ì²´
@Entity
@Table(name = "users")
data class User(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,

    @Column(nullable = false, unique = true)
    val email: String,

    @Column(nullable = false)
    val name: String,

    @CreatedDate
    val createdAt: LocalDateTime = LocalDateTime.now()
)

// DTO (Data Transfer Object): ê³„ì¸µ ê°„ ë°ì´í„° ì „ë‹¬ ê°ì²´
data class UserCreateRequest(
    val email: String,
    val name: String
) {
    fun toEntity() = User(email = email, name = name)
}

data class UserResponse(
    val id: Long,
    val email: String,
    val name: String
)
```

**Entity vs DTO ë¶„ë¦¬ ì´ìœ **:
- EntityëŠ” ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆì™€ ê°•í•˜ê²Œ ê²°í•©
- DTOëŠ” API ìŠ¤í™ê³¼ ê²°í•©í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ ìš”êµ¬ì‚¬í•­ì— ë§ê²Œ ë³€ê²½ ê°€ëŠ¥
- ë¶„ë¦¬ë¥¼ í†µí•´ ê°ê° ë…ë¦½ì ìœ¼ë¡œ ë³€ê²½ ê°€ëŠ¥ (ë‹¨ì¼ ì±…ì„ ì›ì¹™)

### íŒ¨í‚¤ì§€ êµ¬ì¡° ì „ëµ

**1. Layer-based (ê³„ì¸µ ê¸°ë°˜)**
```
src/main/kotlin/com/example/
â”œâ”€â”€ controller/
â”‚   â”œâ”€â”€ UserController.kt
â”‚   â””â”€â”€ OrderController.kt
â”œâ”€â”€ service/
â”‚   â”œâ”€â”€ UserService.kt
â”‚   â””â”€â”€ OrderService.kt
â””â”€â”€ repository/
    â”œâ”€â”€ UserRepository.kt
    â””â”€â”€ OrderRepository.kt
```
- **ì¥ì **: ê³„ì¸µë³„ ì—­í• ì´ ëª…í™•, ì‘ì€ í”„ë¡œì íŠ¸ì— ì í•©
- **ë‹¨ì **: ë„ë©”ì¸ì´ ë¶„ì‚°ë˜ì–´ ì‘ì§‘ë„ ë‚®ìŒ

**2. Feature-based (ê¸°ëŠ¥ ê¸°ë°˜)**
```
src/main/kotlin/com/example/
â”œâ”€â”€ user/
â”‚   â”œâ”€â”€ UserController.kt
â”‚   â”œâ”€â”€ UserService.kt
â”‚   â”œâ”€â”€ UserRepository.kt
â”‚   â””â”€â”€ User.kt
â””â”€â”€ order/
    â”œâ”€â”€ OrderController.kt
    â”œâ”€â”€ OrderService.kt
    â”œâ”€â”€ OrderRepository.kt
    â””â”€â”€ Order.kt
```
- **ì¥ì **: ë†’ì€ ì‘ì§‘ë„, ë„ë©”ì¸ë³„ ë…ë¦½ì  ê°œë°œ ê°€ëŠ¥
- **ë‹¨ì **: ê³µí†µ ì½”ë“œ ê´€ë¦¬ í•„ìš”

## ê¸°ìˆ  ìŠ¤íƒ ì„ ì •

### í•µì‹¬ ì˜ì¡´ì„± ì„¤ëª…
```kotlin
// build.gradle.kts ì˜ˆì‹œ
plugins {
    kotlin("jvm") version "1.9.0"                    // Kotlin JVM í”ŒëŸ¬ê·¸ì¸
    kotlin("plugin.spring") version "1.9.0"          // Spring ì§€ì› (open class ìë™í™”)
    kotlin("plugin.jpa") version "1.9.0"             // JPA ì§€ì› (no-arg ìƒì„±ì ìë™í™”)
    id("org.springframework.boot") version "3.2.0"   // Spring Boot í”ŒëŸ¬ê·¸ì¸
}

dependencies {
    // Spring Boot Starters
    implementation("org.springframework.boot:spring-boot-starter-web")        // RESTful API
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")   // JPA/Hibernate

    // Kotlin ì§€ì›
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")     // JSON ì§ë ¬í™”
    implementation("org.jetbrains.kotlin:kotlin-reflect")                     // Reflection

    // í…ŒìŠ¤íŠ¸
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.8")                              // Kotlin Mocking
}
```

**ì£¼ìš” í”ŒëŸ¬ê·¸ì¸ ì„¤ëª…**:
- `kotlin("plugin.spring")`: Kotlin í´ë˜ìŠ¤ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ finalì¸ë°, Springì€ CGLIB í”„ë¡ì‹œë¥¼ ìœ„í•´ open í´ë˜ìŠ¤ê°€ í•„ìš”. ì´ í”ŒëŸ¬ê·¸ì¸ì´ @Component, @Service ë“±ì´ ë¶™ì€ í´ë˜ìŠ¤ë¥¼ ìë™ìœ¼ë¡œ openìœ¼ë¡œ ë§Œë“¦
- `kotlin("plugin.jpa")`: JPA EntityëŠ” no-arg ìƒì„±ìê°€ í•„ìš”í•œë°, Kotlin data classëŠ” ìƒì„±ì íŒŒë¼ë¯¸í„°ê°€ í•„ìˆ˜. ì´ í”ŒëŸ¬ê·¸ì¸ì´ ìë™ìœ¼ë¡œ no-arg ìƒì„±ìë¥¼ ìƒì„±

## API ì„¤ê³„

### RESTful API ì„¤ê³„ ì›ì¹™
**REST (Representational State Transfer)**: HTTP í”„ë¡œí† ì½œì˜ íŠ¹ì„±ì„ í™œìš©í•œ ì•„í‚¤í…ì²˜ ìŠ¤íƒ€ì¼

**HTTP ë©”ì„œë“œë³„ ìš©ë„**:
- `GET`: ë¦¬ì†ŒìŠ¤ ì¡°íšŒ (ì•ˆì „, ë©±ë“±ì„±)
- `POST`: ë¦¬ì†ŒìŠ¤ ìƒì„±
- `PUT`: ë¦¬ì†ŒìŠ¤ ì „ì²´ ìˆ˜ì • (ë©±ë“±ì„±)
- `PATCH`: ë¦¬ì†ŒìŠ¤ ë¶€ë¶„ ìˆ˜ì •
- `DELETE`: ë¦¬ì†ŒìŠ¤ ì‚­ì œ (ë©±ë“±ì„±)

**API ì—”ë“œí¬ì¸íŠ¸ ì„¤ê³„ ì˜ˆì‹œ**:
```
GET    /api/users          # ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ
GET    /api/users/{id}     # íŠ¹ì • ì‚¬ìš©ì ì¡°íšŒ
POST   /api/users          # ì‚¬ìš©ì ìƒì„±
PUT    /api/users/{id}     # ì‚¬ìš©ì ì „ì²´ ìˆ˜ì •
PATCH  /api/users/{id}     # ì‚¬ìš©ì ë¶€ë¶„ ìˆ˜ì •
DELETE /api/users/{id}     # ì‚¬ìš©ì ì‚­ì œ
```

### Sealed Classë¥¼ í™œìš©í•œ ì‘ë‹µ íƒ€ì… ì„¤ê³„
**Sealed Class**: ì œí•œëœ í•˜ìœ„ í´ë˜ìŠ¤ë§Œ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ì¶”ìƒ í´ë˜ìŠ¤ (ADT - Algebraic Data Type)

```kotlin
// API ì‘ë‹µì„ ì„±ê³µ/ì‹¤íŒ¨ë¡œ ëª…í™•íˆ êµ¬ë¶„
sealed class ApiResponse<out T> {
    data class Success<T>(val data: T) : ApiResponse<T>()
    data class Error(val code: String, val message: String) : ApiResponse<Nothing>()
}

// ì‚¬ìš© ì˜ˆì‹œ
fun getUser(id: Long): ApiResponse<UserResponse> {
    return try {
        val user = userService.getUser(id)
        ApiResponse.Success(user.toResponse())
    } catch (e: NotFoundException) {
        ApiResponse.Error("NOT_FOUND", "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    }
}

// when í‘œí˜„ì‹ìœ¼ë¡œ íƒ€ì… ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
when (val response = getUser(1L)) {
    is ApiResponse.Success -> println(response.data)
    is ApiResponse.Error -> println(response.message)
    // ì»´íŒŒì¼ëŸ¬ê°€ ëª¨ë“  ì¼€ì´ìŠ¤ë¥¼ ì²´í¬ (exhaustive check)
}
```